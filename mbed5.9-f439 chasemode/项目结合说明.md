# Fan Club MkIV 项目结合说明

## 概述

本文档详细说明了如何正确结合 `slave` 和 `slave_bootloader` 两个项目，构建完整的 Fan Club MkIV 固件系统。

## 项目架构

### 内存布局

```
┌─────────────────────────────────────┐
│          STM32F439ZI Flash          │
├─────────────────────────────────────┤
│  0x08000000 - 0x0803FFFF (256KB)    │
│         Bootloader 区域             │
│    (slave_bootloader.bin)           │
├─────────────────────────────────────┤
│  0x08040000 - 0x081FFFFF (1.75MB)   │
│        Application 区域             │
│         (slave.bin)                 │
└─────────────────────────────────────┘
```

### 项目组成

1. **slave_bootloader** - 引导程序
   - 负责系统启动和初始化
   - 提供网络固件更新功能
   - 管理应用程序启动
   - 处理 Flash 操作和错误恢复

2. **slave** - 主应用程序
   - 实现风扇控制逻辑
   - 处理分布式通信
   - 管理传感器数据
   - 提供用户界面和状态报告

## 结合方式

### 1. 配置文件关联

#### Bootloader 配置 (`slave_bootloader/mbed_app.json`)

```json
{
  "target_overrides": {
    "NUCLEO_F439ZI": {
      "target.restrict_size": "0x40000"  // 限制为 256KB
    }
  }
}
```

#### 应用程序配置 (`slave/mbed_app.json`)

```json
{
  "target_overrides": {
    "NUCLEO_F439ZI": {
      "target.bootloader_img": "../slave_bootloader/BUILD/NUCLEO_F439ZI/GCC_ARM-RELEASE/slave_bootloader.bin"
    }
  }
}
```

### 2. 构建顺序

**重要**: 必须按照以下顺序构建，否则会出现依赖错误：

1. **第一步**: 构建 bootloader
   ```bash
   cd slave_bootloader
   mbed compile -t GCC_ARM -m NUCLEO_F439ZI --profile release
   ```

2. **第二步**: 构建应用程序（会自动引用 bootloader）
   ```bash
   cd slave
   mbed compile -t GCC_ARM -m NUCLEO_F439ZI --profile release
   ```

### 3. 自动化构建

使用提供的构建脚本可以自动完成整个过程：

```bash
python build_complete_firmware.py
```

该脚本会：
- 自动创建正确的配置文件
- 按正确顺序构建两个项目
- 复制生成的二进制文件到输出目录
- 生成构建信息报告

## 生成的文件

### Bootloader 文件
- `slave_bootloader.bin` - 引导程序二进制文件 (262,144 字节)
- `slave_bootloader_application.elf` - 调试用 ELF 文件
- `slave_bootloader_application.map` - 内存映射文件

### 应用程序文件
- `slave.bin` - 包含 bootloader 的完整固件 (418,628 字节)
- `slave.hex` - 包含 bootloader 的完整固件 (HEX 格式)
- `slave_application.elf` - 调试用 ELF 文件
- `slave_application.map` - 内存映射文件

## 实际构建结果 (F439)

### 内存使用统计

#### Bootloader 项目 (slave_bootloader)
- **Flash 使用**: 173,896 字节
- **RAM 使用**: 60,980 字节
- **输出文件大小**: 262,144 字节

#### 应用程序项目 (slave)
- **Flash 使用**: 156,559 字节
- **RAM 使用**: 59,684 字节
- **输出文件大小**: 418,628 字节 (包含 bootloader)

### 文件大小对比
- **完整固件 (slave.bin)**: 418,628 字节
- **独立 bootloader (slave_bootloader.bin)**: 262,144 字节
- **应用程序部分估算**: 约 156,484 字节

## 部署方法

### 方法1: 分别烧录

1. 烧录 bootloader:
   ```
   地址: 0x08000000
   文件: slave_bootloader.bin
   ```

2. 烧录应用程序:
   ```
   地址: 0x08040000
   文件: slave.bin
   ```

### 方法2: 完整固件烧录（推荐）

直接烧录包含 bootloader 的完整固件:
```
地址: 0x08000000
文件: slave.hex
```

## 功能分工

### Bootloader 功能

- **网络固件更新**: 通过以太网接收固件更新命令
- **Flash 管理**: 擦除、编程和验证 Flash 内存
- **应用启动**: 验证并启动主应用程序
- **错误处理**: 处理更新失败和恢复
- **通信协议**: 实现与主控的通信协议

### 应用程序功能

- **风扇控制**: PWM 控制和速度调节
- **Chase反馈控制**: 基于PI控制器的智能转速追踪系统
- **PI控制器**: 比例-积分控制算法，实现精确的转速控制
- **传感器接口**: 温度、湿度等传感器数据采集
- **网络通信**: 与主控和其他从机的通信
- **状态管理**: 系统状态监控和报告
- **用户接口**: LED 指示和调试输出

## 通信机制

### Bootloader 与应用程序的交互

1. **启动流程**:
   - Bootloader 检查应用程序完整性
   - 验证通过后跳转到应用程序
   - 应用程序开始正常运行

2. **更新流程**:
   - 应用程序接收更新命令
   - 重启进入 bootloader 模式
   - Bootloader 下载并安装新固件
   - 验证完成后启动新应用程序

### 网络协议

- **标准广播**: `N|PASSCODE|MLPORT`
- **更新命令**: `U|MLPORT|FNAME|FBYTES`
- **启动命令**: `LAUNCH_COMMAND`
- **关闭命令**: `SHUTDOWN_COMMAND`
- **Chase控制命令**: `C|fanID|targetRPM` - 启动风扇转速追踪
- **PI参数设置命令**: `P|fanID|kp|ki` - 设置PI控制器参数

## PI控制系统 (Chase Mode)

### 功能概述

Fan Club MkIV 集成了先进的PI（比例-积分）控制系统，实现精确的风扇转速控制。该系统通过实时反馈调节，能够自动调整PWM占空比，使风扇转速稳定在目标值。

### 核心特性

- **智能转速追踪**: 自动调节PWM输出，实现目标转速的精确控制
- **PI控制算法**: 采用比例-积分控制，具有良好的稳态精度和动态响应
- **实时反馈**: 持续监测风扇实际转速，动态调整控制参数
- **多风扇支持**: 每个风扇独立配置PI参数，支持不同类型风扇的优化控制
- **容差控制**: 可配置转速容差范围，避免不必要的频繁调节

### 实现架构

#### Fan类扩展
- `setTarget(int targetRPM)`: 设置目标转速并启动Chase模式
- `updateChase(float tolerance)`: 执行PI控制更新
- `setPIGains(float kp, float ki)`: 设置PI控制器参数
- `getTarget()`: 获取当前目标转速
- `isChasing()`: 检查是否处于Chase模式

#### Processor类扩展
- `CHASE`命令处理: 解析并执行转速追踪命令
- `PISET`命令处理: 配置PI控制器参数
- 实时反馈循环: 在主处理循环中调用PI更新

### 控制算法

PI控制器采用以下算法：
```
error = targetRPM - currentRPM
proportional = kp * error
integral += ki * error
output = proportional + integral
newDutyCycle = currentDutyCycle + output
```

### 参数配置

#### 推荐PI参数
- **高速风扇** (>2000 RPM): kp=0.1, ki=0.01
- **中速风扇** (1000-2000 RPM): kp=0.15, ki=0.02
- **低速风扇** (<1000 RPM): kp=0.2, ki=0.03

#### 容差设置
- 默认容差: ±50 RPM
- 可通过`chaserTolerance`参数调整
- 建议范围: 20-100 RPM

### 使用方法

#### 启动Chase模式
```
命令格式: C|fanID|targetRPM
示例: C|1|1500  // 风扇1追踪1500 RPM
```

#### 设置PI参数
```
命令格式: P|fanID|kp|ki
示例: P|1|0.15|0.02  // 设置风扇1的PI参数
```

### 性能特征

- **响应时间**: 通常在2-5秒内达到稳态
- **稳态误差**: 小于±10 RPM（在合适的PI参数下）
- **超调量**: 通常小于5%
- **更新频率**: 与主处理循环同步，约100Hz

## 故障排除

### 常见问题

1. **构建顺序错误**
   - 症状: 应用程序构建时找不到 bootloader
   - 解决: 先构建 bootloader，再构建应用程序

2. **路径配置错误**
   - 症状: `target.bootloader_img` 路径不正确
   - 解决: 检查相对路径是否正确

3. **内存大小超限**
   - 症状: Bootloader 超过 256KB 限制
   - 解决: 优化代码或调整功能

4. **PI控制不稳定**
   - 症状: 风扇转速震荡或无法达到目标转速
   - 解决: 调整PI参数，降低kp值或增加容差范围

5. **Chase模式无响应**
   - 症状: 发送CHASE命令后风扇转速无变化
   - 解决: 检查fanID是否正确，确认风扇已初始化

6. **转速读取异常**
   - 症状: 显示的转速值异常或为0
   - 解决: 检查转速传感器连接，验证信号线路

7. **PI参数设置失败**
   - 症状: PISET命令无效果
   - 解决: 确认命令格式正确，检查参数范围是否合理

### 调试建议

1. 使用串口输出查看启动日志
2. 检查 LED 指示状态
3. 验证网络连接和通信
4. 使用调试器检查内存布局
5. 监控PI控制器的实时参数变化
6. 记录转速变化曲线，分析控制效果
7. 使用示波器检查PWM信号质量

## 开发工具

### 必需工具
- Mbed CLI 1.10.5+
- GCC ARM 编译器
- Python 3.6+

### 推荐工具
- STM32CubeProgrammer (固件烧录)
- Wireshark (网络调试)
- PuTTY (串口调试)
- 示波器 (PWM信号分析)
- 转速计 (转速验证)
- Python脚本 (PI参数调优)

## 总结

通过正确配置和构建，`slave` 和 `slave_bootloader` 两个项目可以完美结合，形成一个功能完整的固件更新系统。关键要点：

1. **严格按照构建顺序**: 先 bootloader，后应用程序
2. **正确配置引用路径**: 应用程序必须正确引用 bootloader
3. **遵守内存布局**: Bootloader 限制在 256KB 内
4. **使用自动化脚本**: 减少手动操作错误
5. **合理配置PI参数**: 根据风扇特性选择合适的控制参数
6. **充分测试Chase功能**: 验证转速控制的稳定性和精度

这种架构设计使得系统具备了远程固件更新能力和精确的风扇控制功能，大大提高了维护效率和系统可靠性。集成的PI控制系统为风扇管理提供了智能化的解决方案，能够适应不同的应用场景和性能要求。